#!/bin/bash

set -e

function cmd_help() {
  echo "Usage: $(basename $0) <command> [options]"
  echo
  echo "Commands:"
  echo "  test schema.sql"
  echo "  generate schema.sql"
  echo
}

function cmd_generate_migration() {
  local CURRENT_SCHEMA_FINGERPRINT
  local PREVIOUS_SCHEMA_FILE
  local PREVIOUS_SCHEMA_FINGERPRINT
  local PREVIOUS_SCHEMA_COMMIT
  local POSTGRES_URI
  
  if [ -z "$CURRENT_SCHEMA_FILE" ]; then 
    CURRENT_SCHEMA_FILE=$1
    if [ ! -e "$CURRENT_SCHEMA_FILE" ]; then
      cmd_help
      exit 1
    fi
  fi
  # XXX kill pg_tmp
  # trap '' EXIT
  
  CURRENT_SCHEMA_FINGERPRINT=$(fingerprint_schema $CURRENT_SCHEMA_FILE)
  
  PREVIOUS_SCHEMA_FILE=/tmp/schema_previous.sql
  if ! does_repo_have_commits || ! does_file_exist_in_history $CURRENT_SCHEMA_FILE; then
    echo "No previous revisions of the schema found in the repo history."
    echo "Will diff against an empty schema to produce the initial migration."
    echo
    
    echo "" >$PREVIOUS_SCHEMA_FILE
    PREVIOUS_SCHEMA_COMMIT=none
    PREVIOUS_SCHEMA_FINGERPRINT=none
  elif ! does_file_have_changes $CURRENT_SCHEMA_FILE; then
    echo "Error: there are no uncommitted changes in $CURRENT_SCHEMA_FILE."
    echo 
    echo "Please run this tool before committing changes to the schema file,"
    echo "then commit schema changes and migration together."
    echo
    exit 1    
  else    
    PREVIOUS_SCHEMA_COMMIT=$(git rev-list -1 HEAD $CURRENT_SCHEMA_FILE)
    PREVIOUS_SCHEMA_FINGERPRINT=$(fingerprint_schema $PREVIOUS_SCHEMA_FILE)
    git show ${PREVIOUS_SCHEMA_COMMIT}:${CURRENT_SCHEMA_FILE} >${PREVIOUS_SCHEMA_FILE}
    
    if [ "$CURRENT_SCHEMA_FINGERPRINT" = "$PREVIOUS_SCHEMA_FINGERPRINT" ]; then
      echo "Error: Current schema and last committed schema are equivalent;"
      echo "nothing to do."
      echo
      exit 1
    fi
  fi

  echo "Current schema:"
  echo "  - location: $CURRENT_SCHEMA_FILE"
  echo "  - fingerprint: $CURRENT_SCHEMA_FINGERPRINT"
  echo

  echo "Previous schema:"
  echo "  - commit: ${PREVIOUS_SCHEMA_COMMIT}"
  echo "  - fingerprint: ${PREVIOUS_SCHEMA_FINGERPRINT}"
  echo
  
  ######################################################################

  export PGPORT=15432
  echo -n "Starting postgres... "
  POSTGRES_URI=$(pg_tmp.sh -w 5 -t -p 15432)
  echo "done."
  echo ${POSTGRES_URI}

  ######################################################################

  echo -n "Creating databases and loading schemas... "
  
  psql "${POSTGRES_URI}" -c 'CREATE DATABASE db_previous;' >/dev/null 
  psql "${POSTGRES_URI}" -c 'CREATE DATABASE db_current;' >/dev/null

  DB_PREVIOUS_URI=$(echo $POSTGRES_URI | sed 's|/test|/db_previous|')
  DB_CURRENT_URI=$(echo $POSTGRES_URI | sed 's|/test|/db_current|')
  
  psql "${DB_PREVIOUS_URI}" -v 'ON_ERROR_STOP=1' -1 \
         <$PREVIOUS_SCHEMA_FILE >/dev/null
  psql "${DB_CURRENT_URI}" -v 'ON_ERROR_STOP=1' -1 \
         <$CURRENT_SCHEMA_FILE >/dev/null 
  
  echo "done."

  ######################################################################

  MIGRATION_FILE=migrations/from_${PREVIOUS_SCHEMA_FINGERPRINT}_to_${CURRENT_SCHEMA_FINGERPRINT}.sql
  echo -n "Diff'ing previous and current schemas... "
  # XXX why does migra exit with status code 2?
  docker run --net host migra:local migra --unsafe \
         "${DB_PREVIOUS_URI}" "${DB_CURRENT_URI}" >${MIGRATION_FILE} || true
  echo "done."
  echo

  echo "Migration saved as: ${MIGRATION_FILE}"
  echo
}

function cmd_test() {
  local CURRENT_SCHEMA_FINGERPRINT
  
  if [ -z "$CURRENT_SCHEMA_FILE" ]; then 
    CURRENT_SCHEMA_FILE=$1
    if [ ! -e "$CURRENT_SCHEMA_FILE" ]; then
      cmd_help
      exit 1
    fi
  fi

  CURRENT_SCHEMA_FINGERPRINT=$(fingerprint_schema $CURRENT_SCHEMA_FILE)
  
  echo "Checking migration chain..."

  if verify_migration_chain $CURRENT_SCHEMA_FINGERPRINT; then
    echo "Migration chain is ok."
    echo
  else
    exit 1
  fi
}

function verify_migration_chain() {
  local MIGRATION_FILE
  local TARGET_SCHEMA_FINGERPRINT
  local SOURCE_SCHEMA_FINGERPRINT

  TARGET_SCHEMA_FINGERPRINT=$1
  
  while true; do
    MIGRATION_FILE=$(echo "migrations/from_*_to_${TARGET_SCHEMA_FINGERPRINT}.sql")

    if [ ! -f $MIGRATION_FILE ]; then
      echo "ERROR: Migration to schema $TARGET_SCHEMA_FINGERPRINT missing."
      echo
      return 1
    fi

    SOURCE_SCHEMA_FINGERPRINT=$(echo $MIGRATION_FILE | grep -Po "(?<=from_).+?(?=_to)")

    if [ "$SOURCE_SCHEMA_FINGERPRINT" = "none" ]; then
      break
    fi

    TARGET_SCHEMA_FINGERPRINT=$SOURCE_SCHEMA_FINGERPRINT
  done
}

function fingerprint_schema() {
  local SCHEMA_FILE=$1
  ruby -rpg_query -e 'puts PgQuery.fingerprint(STDIN.read)' <$SCHEMA_FILE
}

function does_file_have_changes() {
  local FILE
  FILE=$1
  if git diff --exit-code $FILE >/dev/null; then
    return 1
  else
    return 0
  fi
}

function does_repo_have_commits() {
  test "$(git rev-parse HEAD 2>/dev/null)" != "HEAD"
}

function does_file_exist_in_history() {
  local FILE=$1
  git ls-files --error-unmatch $CURRENT_SCHEMA_FILE >/dev/null 2>&1
}

function dispatch_command() {
  COMMAND=$1
  case $COMMAND in
    "" | "-h" | "--help")
      cmd_help
      ;;
    test)
      shift
      cmd_test "$@"
      ;;
    generate)
      shift
      cmd_generate_migration "$@"
      ;;
    *)
      echo "Error: '$COMMAND' not recognized." >&2
      echo "       Run '$(basename $0) --help' for a list of commands." >&2
      exit 1
      ;;
  esac
}


dispatch_command $@
